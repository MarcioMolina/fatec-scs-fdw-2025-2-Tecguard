def _detect_ddos(self, pkt):
        """Detecta vários tipos de ataques DDoS"""
        if not pkt.haslayer(IP):
            return

        src_ip = pkt[IP].src
        current_time = time.time()

        # 1. Análise de Volume Básico
        stats = self.ddos_traffic[src_ip]
        
        # Reinicia contador se a janela de tempo expirou (1 segundo)
        if current_time - stats['start_time'] > 1.0:
            stats['count'] = 0
            stats['start_time'] = current_time
            stats['total_size'] = 0
        
        stats['count'] += 1
        stats['total_size'] += len(pkt)

        # Verifica limites
        if stats['count'] > self.ddos_thresholds['packet_rate']:
            alert_msg = f"DDoS (Volume) detectado: {src_ip} - {stats['count']} pps"
            print(f"[!] {alert_msg}")
            self._block_ip(src_ip, alert_msg)
        
        if stats['total_size'] > self.ddos_thresholds['bandwidth']:
            alert_msg = f"DDoS (Largura de Banda) detectado: {src_ip} - {stats['total_size']/1e6:.2f} Mbps"
            print(f"[!] {alert_msg}")
            self._block_ip(src_ip, alert_msg)

 def _detect_ddos(self, pkt):
        """Detecta vários tipos de ataques DDoS"""
        if not pkt.haslayer(IP):
            return

        src_ip = pkt[IP].src
        current_time = time.time()

        # 1. Análise de Volume Básico
        stats = self.ddos_traffic[src_ip]
        
        # Reinicia contador se a janela de tempo expirou (1 segundo)
        if current_time - stats['start_time'] > 1.0:
            stats['count'] = 0
            stats['start_time'] = current_time
            stats['total_size'] = 0
        
        stats['count'] += 1
        stats['total_size'] += len(pkt)

        # Verifica limites
        if stats['count'] > self.ddos_thresholds['packet_rate']:
            alert_msg = f"DDoS (Volume) detectado: {src_ip} - {stats['count']} pps"
            print(f"[!] {alert_msg}")
            self._block_ip(src_ip, alert_msg)
        
        if stats['total_size'] > self.ddos_thresholds['bandwidth']:
            alert_msg = f"DDoS (Largura de Banda) detectado: {src_ip} - {stats['total_size']/1e6:.2f} Mbps"
            print(f"[!] {alert_msg}")
            self._block_ip(src_ip, alert_msg)

def _analyze_http(self, pkt, payload):
        #Inspeção profunda de HTTP
        try:
            payload_str = payload.decode(errors='ignore')
            
            for threat_type, pattern in self.http_patterns.items():
                if pattern.search(payload_str):
                    self.stats['dpi_alerts'] += 1
                    self.stats['last_alert'] = time.time()
                    
                    alert_msg = f"Ataque HTTP detectado: {threat_type.upper()}"
                    self.alert_triggered.emit(alert_msg)
                    
                    print(f"[!] {alert_msg}")
                    self._block_ip(pkt[IP].src, f"HTTP {threat_type}")
                    
            if "User-Agent:" in payload_str:
                user_agent = payload_str.split("User-Agent:")[1].split("\r\n")[0].strip()
                print(f"[HTTP] User-Agent: {user_agent}")
                
        except Exception as e:
            print(f"[HTTP] Erro: {str(e)}")

def _analyze_ja3(self, pkt):
        """Analisa fingerprint JA3 com tratamento de cifras desconhecidas"""
        try:
            if not pkt.haslayer(TLS):
                return

            # Verifica se é um Client Hello
            client_hello = None
            for msg in pkt[TLS].msg:
                if hasattr(msg, 'msgtype') and msg.msgtype == 1:  # Client Hello
                    client_hello = msg
                    break

            if not client_hello:
                return

            # Filtra cifras não padrão e registra anomalias
            valid_ciphers = []
            if hasattr(client_hello, 'ciphers'):
                for cipher in client_hello.ciphers:
                    if 0x0000 < cipher <= 0xFFFF:  # Cifras IANA válidas
                        valid_ciphers.append(cipher)
                    else:
                        self._log_tls_anomaly(pkt, f"Non-standard cipher: {cipher}")

            # Substitui a lista de cifras pela filtrada
            if hasattr(client_hello, 'ciphers'):
                client_hello.ciphers = valid_ciphers

            # Continua com o cálculo JA3 normal
            ja3_hash = self._calculate_ja3(pkt[TLS])
            if ja3_hash and self.ja3_db.is_malicious(ja3_hash):
                self._handle_malicious_ja3(pkt, ja3_hash)

        except Exception as e:
            print(f"[JA3] Erro durante análise: {str(e)}")


def _calculate_ja3(self, tls_layer):
        """Calcula o fingerprint JA3 com tratamento robusto"""
        try:
            if not tls_layer or not hasattr(tls_layer, 'msg'):
                return None

            # Encontra a mensagem Client Hello
            client_hello = next(
                (msg for msg in tls_layer.msg 
                if hasattr(msg, 'msgtype') and msg.msgtype == 1),
                None
            )
            if not client_hello:
                return None

            # Versão TLS
            version = getattr(client_hello, 'version', '769')  # Fallback TLS 1.0

            # Cifras válidas (filtra valores fora do padrão)
            ciphers = []
            if hasattr(client_hello, 'ciphers'):
                ciphers = [
                    str(c) for c in client_hello.ciphers 
                    if isinstance(c, int) and 0x0000 < c <= 0xFFFF
                ]

            # Extensões TLS
            extensions = []
            if hasattr(client_hello, 'extensions'):
                extensions = [
                    str(e.type) for e in client_hello.extensions 
                    if hasattr(e, 'type')
                ]

            # Gera string JA3
            ja3_str = f"{version}," \
                    f"{'-'.join(ciphers) if ciphers else ''}," \
                    f"{'-'.join(extensions) if extensions else ''}"

            return hashlib.md5(ja3_str.encode()).hexdigest()

        except Exception as e:
            logging.error(f"Erro no cálculo JA3: {str(e)}")
            return None
